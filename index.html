<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Monthly Art Vol.2 - Boiling Point: Emerging Artists & Spaces in Seoul</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- PageFlip -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip/dist/css/page-flip.min.css">
  <script src="https://cdn.jsdelivr.net/npm/page-flip/dist/js/page-flip.browser.min.js"></script>
  <style>
    :root { --bg:#0b0c10; --panel:#151821; --text:#e9eef6; --muted:#9aa3b2; --accent:#46b3ff; --paper-dark:#0e1117; }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0d1017,#0b0c10);color:var(--text);font-family:system-ui,"Noto Sans KR",sans-serif}
    .app{display:grid;grid-template-rows:auto 1fr auto;height:100%;gap:10px}
    .toolbar,.footer{background:#151821cc;backdrop-filter:blur(6px);padding:10px 12px;display:flex;align-items:center;gap:10px;border-block:1px solid #222938}
    .spacer{flex:1}
    .btn{border:1px solid #2a3143;background:#1a1f2c;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    .field{display:inline-flex;align-items:center;gap:6px;border:1px solid #2a3143;border-radius:10px;padding:6px 10px;background:#101522}
    .range{width:160px;accent-color:var(--accent)}
    .hint{color:var(--muted);font-size:13px}

    /* 뷰포트/줌 레이어 */
    #viewer{position:relative;display:grid;place-items:center;overflow:hidden;touch-action:none;background:transparent;}
    #zoomLayer{
      position:relative;width:fit-content;height:fit-content;
      transform-origin: 0 0; /* 줌 중심 계산을 쉽게 하기 위해 좌상단 기준 */
      cursor: grab; user-select: none;
      background:var(--paper-dark); /* 책 뒤 배경 */
    }
    #zoomLayer.dragging{cursor: grabbing;}

    /* PageFlip 루트 */
    #flip{
      position:relative; width:min(95vw,1400px); height:min(85vh,900px);
      transition: none; /* 줌/패닝 즉각 반영 */
      background:var(--paper-dark);
    }
    /* PageFlip 내부 캔버스 배경도 어둡게 */
    .stf__canvas, .stf_canvas, #flip canvas { background:var(--paper-dark) !important; }

    input[type="number"]{width:70px;background:transparent;border:none;color:inherit;text-align:right;font-weight:700}
    #status{font-weight:600}
  </style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <div class="field"><span id="bookTitle" style="font-weight:700">Boiling Point: Emerging Artists & Spaces in Korea</span></div>
    <div class="spacer"></div>
    <div id="status" class="hint">Loading…</div>

    <button id="prev" class="btn">◀ Prev</button>
    <div class="field">
      <span>Page</span>
      <input id="page" type="number" min="1" value="1">
      <span id="total">/ 0</span>
    </div>
    <button id="next" class="btn">Next ▶</button>

    <div class="field">
      <span>Zoom</span>
      <!-- 25% ~ 400% -->
      <input id="zoom" class="range" type="range" min="25" max="400" value="100">
      <span id="zoomLbl">100%</span>
    </div>

    <!-- 스프레드 고정 (단면 토글 없음) -->
    <button id="fs" class="btn" title="전체화면">⛶ Full</button>
  </div>

  <!-- 뷰어 -->
  <div id="viewer">
    <div id="zoomLayer">
      <div id="flip"></div>
    </div>
  </div>

  <div class="footer" style="justify-content:space-between">
    <div class="hint">ⓒ Wolganmisool Publications, Inc. 2025 All Right Reserved.</div>
    <div class="hint"></div>
  </div>
</div>

<script>
  // ===== 기본 매니페스트 경로(상대경로) =====
  const DEFAULT_MANIFEST = "./manifest.json";

  // ===== 쿼리 파라미터로 매니페스트 지정 가능 =====
  const qp = new URLSearchParams(location.search);
  const manifestArg = qp.get("manifest") || DEFAULT_MANIFEST;

  // ===== UI 엘리먼트 =====
  const viewer = document.getElementById('viewer');
  const zoomLayer = document.getElementById('zoomLayer');
  const flipRoot = document.getElementById('flip');
  const bookTitleEl = document.getElementById('bookTitle');
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const pageInput = document.getElementById('page');
  const totalEl = document.getElementById('total');
  const zoomRange = document.getElementById('zoom');
  const zoomLbl = document.getElementById('zoomLbl');
  const fsBtn = document.getElementById('fs');
  const statusEl = document.getElementById('status');

  // ========== 상태 ==========
  let pageFlip = null;
  let currentPages = [];

  // 줌/패닝 상태
  const MIN_SCALE = 0.25, MAX_SCALE = 4.0;
  let scale = 1;      // 배율
  let tx = 0, ty = 0; // 평행이동(px), transform-origin: 0 0 가정

  function setStatus(msg){ statusEl.textContent = msg; }

  // 자연 정렬
  function naturalSort(a,b){
    const coll = new Intl.Collator(undefined, { numeric:true, sensitivity:'base' });
    return coll.compare(a,b);
  }
  function toAbs(urlLike, baseHref){
    try { return new URL(urlLike, baseHref).href; } catch { return urlLike; }
  }

  // ====== PageFlip 초기화 (항상 스프레드) ======
  function initFlip(imageURLs){
    flipRoot.innerHTML = '';
    if(pageFlip){ pageFlip.destroy(); pageFlip=null; }
    pageFlip = new St.PageFlip(flipRoot, {
      width: 1240, height: 1624,          // 원본 이미지 비율
      size: "stretch",
      minWidth: 380, maxWidth: 1800,
      minHeight: 400, maxHeight: 2000,
      usePortrait: false,                  // 단면 금지
      showCover: true,
      maxShadowOpacity: .2,
      mobileScrollSupport: true,
      disableFlipByClick: false            // 확대 중엔 아래에서 이벤트 차단
    });
    pageFlip.loadFromImages(imageURLs);
    totalEl.textContent = `/ ${imageURLs.length}`;
    pageInput.min = 1; pageInput.max = imageURLs.length; pageInput.value = 1;
    pageFlip.on('flip', e => { pageInput.value = e.data + 1; });
  }

  // ====== manifest ======
  async function fetchManifest(url){
    setStatus(`Fetching manifest: ${url}`);
    const res = await fetch(url, { cache: 'no-store' });
    if(!res.ok){
      const msg = `HTTP ${res.status} ${res.statusText} (manifest)\nURL: ${res.url}`;
      setStatus(msg); throw new Error(msg);
    }
    try { return await res.json(); }
    catch (e) { setStatus('manifest JSON 파싱 실패'); throw e; }
  }
  function normalizeManifest(manifest, manifestUrl){
    if (Array.isArray(manifest)) {
      const pages = [...manifest].sort(naturalSort).map(p => toAbs(p, manifestUrl));
      return { title: 'Monthly Art – Flipbook', pages };
    }
    if (manifest && Array.isArray(manifest.pages)) {
      const base = manifest.base ? toAbs(manifest.base, manifestUrl) : manifestUrl;
      const pages = manifest.pages.map(p => toAbs(p, base)).sort(naturalSort);
      return { title: manifest.title || 'Monthly Art – Flipbook', pages };
    }
    throw new Error('지원하지 않는 manifest 형식입니다.');
  }

  // ====== Zoom/Pan 엔진 ======
  function applyTransform(){
    zoomLayer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`;
    // 확대 상태에선 PageFlip 제스처와 충돌 방지: 이벤트 캡처로 막아줌(아래)
  }

  function centerWithinViewport(){
    // 콘텐츠(스케일 적용 전) 크기
    const contentW = flipRoot.offsetWidth;
    const contentH = flipRoot.offsetHeight;
    const vw = viewer.clientWidth, vh = viewer.clientHeight;
    const scaledW = contentW * scale;
    const scaledH = contentH * scale;

    // 가운데 정렬 / 가장자리 클램프
    if (scaledW <= vw) tx = (vw - scaledW) / 2;
    else tx = Math.min(0, Math.max(tx, vw - scaledW));

    if (scaledH <= vh) ty = (vh - scaledH) / 2;
    else ty = Math.min(0, Math.max(ty, vh - scaledH));
  }

  function setScale(newScale, focalX, focalY){
    // focalX/Y: viewer 좌표계 기준 (없으면 중앙)
    const rect = viewer.getBoundingClientRect();
    const cx = (focalX !== undefined) ? focalX : rect.width/2;
    const cy = (focalY !== undefined) ? focalY : rect.height/2;

    const prev = scale;
    const next = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

    // 포커스 고정 줌: (cx,cy) 지점이 화면에서 유지되도록 이동량 조정
    // 변환 기준(0,0)에서 현재 포커스의 콘텐츠 좌표
    const px = (cx - tx) / prev;
    const py = (cy - ty) / prev;

    scale = next;
    tx = cx - px * scale;
    ty = cy - py * scale;

    centerWithinViewport();
    applyTransform();
    // UI 동기화
    const pct = Math.round(scale * 100);
    zoomRange.value = pct;
    zoomLbl.textContent = `${pct}%`;
  }

  // 초기 배치(100%)
  function resetView(){
    scale = 1; tx = 0; ty = 0;
    centerWithinViewport();
    applyTransform();
    const pct = 100;
    zoomRange.value = pct;
    zoomLbl.textContent = `${pct}%`;
  }

  // ====== 컨트롤: 버튼/입력 ======
  prevBtn.addEventListener('click', ()=>pageFlip?.flipPrev());
  nextBtn.addEventListener('click', ()=>pageFlip?.flipNext());
  pageInput.addEventListener('change', ()=>{
    if(!pageFlip) return;
    const n = Math.max(1, Math.min(parseInt(pageInput.value||'1',10), pageFlip.getPageCount()));
    pageFlip.flip(n-1); pageInput.value = n;
  });
  zoomRange.addEventListener('input', ()=>{
    const val = parseInt(zoomRange.value, 10);
    setScale(val/100);
  });
  fsBtn.addEventListener('click', ()=>{
    const el = viewer;
    if(!document.fullscreenElement){
      (el.requestFullscreen || el.webkitRequestFullscreen || document.documentElement.requestFullscreen).call(el);
    } else {
      (document.exitFullscreen || document.webkitExitFullscreen || document.cancelFullscreen).call(document);
    }
  });

  // ====== 휠 줌 ======
  viewer.addEventListener('wheel', (e)=>{
    e.preventDefault(); // 페이지 스크롤 대신 뷰어 줌
    const rect = viewer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // deltaY에 따라 1.12배/0.89배 정도로 부드럽게
    const zoomFactor = (e.deltaY < 0) ? 1.12 : 0.89;
    setScale(scale * zoomFactor, x, y);
  }, { passive: false });

  // ====== 드래그 패닝 & 핀치 줌 (Pointer Events) ======
  const pointers = new Map(); // pointerId -> {x,y}
  let isDragging = false;
  let dragLast = { x:0, y:0 };

  // 핀치 상태
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchPrevCenter = { x:0, y:0 };

  function distance(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx,dy);
    }
  function midpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  viewer.addEventListener('pointerdown', (e)=>{
    // 확대 상태에선 PageFlip 제스처와 충돌할 수 있어 캡처/차단
    if (scale > 1){ e.stopPropagation(); }
    viewer.setPointerCapture(e.pointerId);
    const rect = viewer.getBoundingClientRect();
    pointers.set(e.pointerId, { x: e.clientX - rect.left, y: e.clientY - rect.top });

    if (pointers.size === 1 && scale > 1){
      isDragging = true;
      zoomLayer.classList.add('dragging');
      dragLast = pointers.get(e.pointerId);
    } else if (pointers.size === 2){
      const [p1,p2] = [...pointers.values()];
      pinchStartDist = distance(p1,p2);
      pinchStartScale = scale;
      pinchPrevCenter = midpoint(p1,p2);
    }
  });

  viewer.addEventListener('pointermove', (e)=>{
    if (!pointers.has(e.pointerId)) return;
    const rect = viewer.getBoundingClientRect();
    pointers.set(e.pointerId, { x: e.clientX - rect.left, y: e.clientY - rect.top });

    if (pointers.size === 2){
      // 핀치 줌 + 중심 이동에 따른 팬
      const [a,b] = [...pointers.values()];
      const dist = distance(a,b);
      const center = midpoint(a,b);
      const scaleFactor = dist / Math.max(1, pinchStartDist);
      const targetScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, pinchStartScale * scaleFactor));
      // 중심 기준 줌
      setScale(targetScale, center.x, center.y);
      // 중심 이동분 만큼 팬
      tx += (center.x - pinchPrevCenter.x);
      ty += (center.y - pinchPrevCenter.y);
      centerWithinViewport();
      applyTransform();
      pinchPrevCenter = center;
      e.stopPropagation();
    } else if (isDragging && scale > 1){
      const cur = pointers.get(e.pointerId);
      const dx = cur.x - dragLast.x;
      const dy = cur.y - dragLast.y;
      dragLast = cur;
      tx += dx; ty += dy;
      centerWithinViewport();
      applyTransform();
      e.stopPropagation();
    }
  });

  function endPointer(e){
    if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
    if (pointers.size < 2){
      pinchStartDist = 0;
    }
    if (pointers.size === 0){
      isDragging = false;
      zoomLayer.classList.remove('dragging');
    }
  }
  viewer.addEventListener('pointerup', endPointer);
  viewer.addEventListener('pointercancel', endPointer);
  viewer.addEventListener('pointerleave', endPointer);

  // 창 크기 변경시 가운데 정렬/클램프
  window.addEventListener('resize', ()=>{
    centerWithinViewport();
    applyTransform();
  });

  // ====== 초기 로드 ======
  (async ()=>{
    try{
      const absManifestUrl = toAbs(manifestArg, location.href);
      const raw = await fetchManifest(absManifestUrl);
      const normalized = normalizeManifest(raw, absManifestUrl);

      bookTitleEl.textContent = normalized.title || 'Monthly Art – Flipbook';
      currentPages = normalized.pages;
      if (!currentPages.length) { setStatus('manifest에 페이지가 없습니다.'); return; }

      // 혼합콘텐츠 경고
      const pageUrl = new URL(location.href);
      if (pageUrl.protocol === 'https:' && currentPages.some(u => u.startsWith('http://'))) {
        setStatus('경고: https 페이지에서 http 이미지를 불러오면 차단될 수 있습니다.');
      }

      setStatus(`Pages: ${currentPages.length} (initializing)`);
      initFlip(currentPages);
      setStatus('Ready');

      // 초기가운데 배치
      resetView();
    }catch(e){
      console.error(e);
      setStatus('로드 오류: ' + (e.message || e));
    }
  })();

  // (옵션) 더블클릭으로 2배 토글 — 원하시면 주석 해제
  // viewer.addEventListener('dblclick', (e)=>{
  //   const rect = viewer.getBoundingClientRect();
  //   const x = e.clientX - rect.left, y = e.clientY - rect.top;
  //   const target = (scale < 2) ? 2 : 1;
  //   setScale(target, x, y);
  // });

  // (기존) 마우스 우클릭 방지
  document.addEventListener('contextmenu', (e) => {
    // 특정 영역만 제한하려면 e.target.closest('#viewer') 조건 추가
    e.preventDefault();
  }, { capture: true });
</script>
</body>
</html>
